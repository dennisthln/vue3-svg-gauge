import { createElementBlock, openBlock, createCommentVNode, createElementVNode, Fragment, renderList, renderSlot, getCurrentInstance } from "vue";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var Tween = { exports: {} };
(function(module, exports) {
  var _Group = function() {
    this._tweens = {};
    this._tweensAddedDuringUpdate = {};
  };
  _Group.prototype = {
    getAll: function() {
      return Object.keys(this._tweens).map((function(tweenId) {
        return this._tweens[tweenId];
      }).bind(this));
    },
    removeAll: function() {
      this._tweens = {};
    },
    add: function(tween) {
      this._tweens[tween.getId()] = tween;
      this._tweensAddedDuringUpdate[tween.getId()] = tween;
    },
    remove: function(tween) {
      delete this._tweens[tween.getId()];
      delete this._tweensAddedDuringUpdate[tween.getId()];
    },
    update: function(time, preserve) {
      var tweenIds = Object.keys(this._tweens);
      if (tweenIds.length === 0) {
        return false;
      }
      time = time !== void 0 ? time : TWEEN2.now();
      while (tweenIds.length > 0) {
        this._tweensAddedDuringUpdate = {};
        for (var i = 0; i < tweenIds.length; i++) {
          var tween = this._tweens[tweenIds[i]];
          if (tween && tween.update(time) === false) {
            tween._isPlaying = false;
            if (!preserve) {
              delete this._tweens[tweenIds[i]];
            }
          }
        }
        tweenIds = Object.keys(this._tweensAddedDuringUpdate);
      }
      return true;
    }
  };
  var TWEEN2 = new _Group();
  TWEEN2.Group = _Group;
  TWEEN2._nextId = 0;
  TWEEN2.nextId = function() {
    return TWEEN2._nextId++;
  };
  if (typeof window === "undefined" && typeof process !== "undefined" && process.hrtime) {
    TWEEN2.now = function() {
      var time = process.hrtime();
      return time[0] * 1e3 + time[1] / 1e6;
    };
  } else if (typeof window !== "undefined" && window.performance !== void 0 && window.performance.now !== void 0) {
    TWEEN2.now = window.performance.now.bind(window.performance);
  } else if (Date.now !== void 0) {
    TWEEN2.now = Date.now;
  } else {
    TWEEN2.now = function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
  TWEEN2.Tween = function(object, group) {
    this._object = object;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1e3;
    this._repeat = 0;
    this._repeatDelayTime = void 0;
    this._yoyo = false;
    this._isPlaying = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = null;
    this._easingFunction = TWEEN2.Easing.Linear.None;
    this._interpolationFunction = TWEEN2.Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallback = null;
    this._onStartCallbackFired = false;
    this._onUpdateCallback = null;
    this._onCompleteCallback = null;
    this._onStopCallback = null;
    this._group = group || TWEEN2;
    this._id = TWEEN2.nextId();
  };
  TWEEN2.Tween.prototype = {
    getId: function getId() {
      return this._id;
    },
    isPlaying: function isPlaying() {
      return this._isPlaying;
    },
    to: function to(properties, duration) {
      this._valuesEnd = properties;
      if (duration !== void 0) {
        this._duration = duration;
      }
      return this;
    },
    start: function start(time) {
      this._group.add(this);
      this._isPlaying = true;
      this._onStartCallbackFired = false;
      this._startTime = time !== void 0 ? typeof time === "string" ? TWEEN2.now() + parseFloat(time) : time : TWEEN2.now();
      this._startTime += this._delayTime;
      for (var property in this._valuesEnd) {
        if (this._valuesEnd[property] instanceof Array) {
          if (this._valuesEnd[property].length === 0) {
            continue;
          }
          this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
        }
        if (this._object[property] === void 0) {
          continue;
        }
        this._valuesStart[property] = this._object[property];
        if (this._valuesStart[property] instanceof Array === false) {
          this._valuesStart[property] *= 1;
        }
        this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
      }
      return this;
    },
    stop: function stop() {
      if (!this._isPlaying) {
        return this;
      }
      this._group.remove(this);
      this._isPlaying = false;
      if (this._onStopCallback !== null) {
        this._onStopCallback(this._object);
      }
      this.stopChainedTweens();
      return this;
    },
    end: function end() {
      this.update(this._startTime + this._duration);
      return this;
    },
    stopChainedTweens: function stopChainedTweens() {
      for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
        this._chainedTweens[i].stop();
      }
    },
    group: function group(group) {
      this._group = group;
      return this;
    },
    delay: function delay(amount) {
      this._delayTime = amount;
      return this;
    },
    repeat: function repeat(times) {
      this._repeat = times;
      return this;
    },
    repeatDelay: function repeatDelay(amount) {
      this._repeatDelayTime = amount;
      return this;
    },
    yoyo: function yoyo(yy) {
      this._yoyo = yy;
      return this;
    },
    easing: function easing(eas) {
      this._easingFunction = eas;
      return this;
    },
    interpolation: function interpolation(inter) {
      this._interpolationFunction = inter;
      return this;
    },
    chain: function chain() {
      this._chainedTweens = arguments;
      return this;
    },
    onStart: function onStart(callback) {
      this._onStartCallback = callback;
      return this;
    },
    onUpdate: function onUpdate(callback) {
      this._onUpdateCallback = callback;
      return this;
    },
    onComplete: function onComplete(callback) {
      this._onCompleteCallback = callback;
      return this;
    },
    onStop: function onStop(callback) {
      this._onStopCallback = callback;
      return this;
    },
    update: function update(time) {
      var property;
      var elapsed;
      var value;
      if (time < this._startTime) {
        return true;
      }
      if (this._onStartCallbackFired === false) {
        if (this._onStartCallback !== null) {
          this._onStartCallback(this._object);
        }
        this._onStartCallbackFired = true;
      }
      elapsed = (time - this._startTime) / this._duration;
      elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
      value = this._easingFunction(elapsed);
      for (property in this._valuesEnd) {
        if (this._valuesStart[property] === void 0) {
          continue;
        }
        var start = this._valuesStart[property] || 0;
        var end = this._valuesEnd[property];
        if (end instanceof Array) {
          this._object[property] = this._interpolationFunction(end, value);
        } else {
          if (typeof end === "string") {
            if (end.charAt(0) === "+" || end.charAt(0) === "-") {
              end = start + parseFloat(end);
            } else {
              end = parseFloat(end);
            }
          }
          if (typeof end === "number") {
            this._object[property] = start + (end - start) * value;
          }
        }
      }
      if (this._onUpdateCallback !== null) {
        this._onUpdateCallback(this._object);
      }
      if (elapsed === 1) {
        if (this._repeat > 0) {
          if (isFinite(this._repeat)) {
            this._repeat--;
          }
          for (property in this._valuesStartRepeat) {
            if (typeof this._valuesEnd[property] === "string") {
              this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
            }
            if (this._yoyo) {
              var tmp = this._valuesStartRepeat[property];
              this._valuesStartRepeat[property] = this._valuesEnd[property];
              this._valuesEnd[property] = tmp;
            }
            this._valuesStart[property] = this._valuesStartRepeat[property];
          }
          if (this._yoyo) {
            this._reversed = !this._reversed;
          }
          if (this._repeatDelayTime !== void 0) {
            this._startTime = time + this._repeatDelayTime;
          } else {
            this._startTime = time + this._delayTime;
          }
          return true;
        } else {
          if (this._onCompleteCallback !== null) {
            this._onCompleteCallback(this._object);
          }
          for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].start(this._startTime + this._duration);
          }
          return false;
        }
      }
      return true;
    }
  };
  TWEEN2.Easing = {
    Linear: {
      None: function(k) {
        return k;
      }
    },
    Quadratic: {
      In: function(k) {
        return k * k;
      },
      Out: function(k) {
        return k * (2 - k);
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      }
    },
    Cubic: {
      In: function(k) {
        return k * k * k;
      },
      Out: function(k) {
        return --k * k * k + 1;
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
      }
    },
    Quartic: {
      In: function(k) {
        return k * k * k * k;
      },
      Out: function(k) {
        return 1 - --k * k * k * k;
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
      }
    },
    Quintic: {
      In: function(k) {
        return k * k * k * k * k;
      },
      Out: function(k) {
        return --k * k * k * k * k + 1;
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      }
    },
    Sinusoidal: {
      In: function(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      Out: function(k) {
        return Math.sin(k * Math.PI / 2);
      },
      InOut: function(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
    },
    Exponential: {
      In: function(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      },
      Out: function(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      },
      InOut: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if ((k *= 2) < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      }
    },
    Circular: {
      In: function(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      Out: function(k) {
        return Math.sqrt(1 - --k * k);
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      }
    },
    Elastic: {
      In: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
      },
      Out: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
      },
      InOut: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        k *= 2;
        if (k < 1) {
          return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
        }
        return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
      }
    },
    Back: {
      In: function(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      Out: function(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      InOut: function(k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      }
    },
    Bounce: {
      In: function(k) {
        return 1 - TWEEN2.Easing.Bounce.Out(1 - k);
      },
      Out: function(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      },
      InOut: function(k) {
        if (k < 0.5) {
          return TWEEN2.Easing.Bounce.In(k * 2) * 0.5;
        }
        return TWEEN2.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
      }
    }
  };
  TWEEN2.Interpolation = {
    Linear: function(v, k) {
      var m = v.length - 1;
      var f = m * k;
      var i = Math.floor(f);
      var fn = TWEEN2.Interpolation.Utils.Linear;
      if (k < 0) {
        return fn(v[0], v[1], f);
      }
      if (k > 1) {
        return fn(v[m], v[m - 1], m - f);
      }
      return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function(v, k) {
      var b = 0;
      var n = v.length - 1;
      var pw = Math.pow;
      var bn = TWEEN2.Interpolation.Utils.Bernstein;
      for (var i = 0; i <= n; i++) {
        b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
      }
      return b;
    },
    CatmullRom: function(v, k) {
      var m = v.length - 1;
      var f = m * k;
      var i = Math.floor(f);
      var fn = TWEEN2.Interpolation.Utils.CatmullRom;
      if (v[0] === v[m]) {
        if (k < 0) {
          i = Math.floor(f = m * (1 + k));
        }
        return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
      } else {
        if (k < 0) {
          return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
        }
        if (k > 1) {
          return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }
        return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
      }
    },
    Utils: {
      Linear: function(p0, p1, t) {
        return (p1 - p0) * t + p0;
      },
      Bernstein: function(n, i) {
        var fc = TWEEN2.Interpolation.Utils.Factorial;
        return fc(n) / fc(i) / fc(n - i);
      },
      Factorial: /* @__PURE__ */ function() {
        var a = [1];
        return function(n) {
          var s = 1;
          if (a[n]) {
            return a[n];
          }
          for (var i = n; i > 1; i--) {
            s *= i;
          }
          a[n] = s;
          return s;
        };
      }(),
      CatmullRom: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    }
  };
  (function(root2) {
    {
      module.exports = TWEEN2;
    }
  })();
})(Tween);
var TweenExports = Tween.exports;
const TWEEN = /* @__PURE__ */ getDefaultExportFromCjs(TweenExports);
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$3 = freeGlobal || freeSelf || Function("return this")();
var _root = root$3;
var root$2 = _root;
var Symbol$4 = root$2.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
var nativeObjectToString$1 = objectProto$4.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$3.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$3 = Object.prototype;
var nativeObjectToString = objectProto$3.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$2(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$2;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$1;
var baseGetTag$1 = _baseGetTag, isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$3(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag$1(value) == symbolTag;
}
var isSymbol_1 = isSymbol$3;
var isArray$2 = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$2;
var baseGetTag = _baseGetTag, isObject$1 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$1;
var root$1 = _root;
var coreJsData$1 = root$1["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$1;
var isFunction = isFunction_1, isMasked = _isMasked, isObject = isObject_1, toSource = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$2(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$2;
var getNative$1 = _getNative;
var nativeCreate$4 = getNative$1(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$1;
var eq = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = listCacheClear;
ListCache$1.prototype["delete"] = listCacheDelete;
ListCache$1.prototype.get = listCacheGet;
ListCache$1.prototype.has = listCacheHas;
ListCache$1.prototype.set = listCacheSet;
var _ListCache = ListCache$1;
var getNative = _getNative, root = _root;
var Map$1 = getNative(root, "Map");
var _Map = Map$1;
var Hash = _Hash, ListCache = _ListCache, Map = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map || ListCache)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var Symbol$1 = _Symbol, arrayMap = _arrayMap, isArray$1 = isArray_1, isSymbol$1 = isSymbol_1;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var isArray = isArray_1, isKey = _isKey, stringToPath = _stringToPath, toString = toString_1;
function castPath$1(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
var _castPath = castPath$1;
var isSymbol = isSymbol_1;
function toKey$1(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
var _toKey = toKey$1;
var castPath = _castPath, toKey = _toKey;
function baseGet$1(object, path) {
  path = castPath(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$1;
var baseGet = _baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
const _get = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const RADIUS = 100;
const X_CENTER = 100;
const Y_CENTER = 100;
function polarToCartesian(radius, angle) {
  const angleInRadians = (angle - 90) * Math.PI / 180;
  return {
    x: X_CENTER + radius * Math.cos(angleInRadians),
    y: Y_CENTER + radius * Math.sin(angleInRadians)
  };
}
function describePath(radius, startAngle, endAngle) {
  const start = polarToCartesian(radius, endAngle);
  const end = polarToCartesian(radius, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  const d = [
    "M",
    start.x,
    start.y,
    "A",
    radius,
    radius,
    0,
    largeArcFlag,
    0,
    end.x,
    end.y,
    "L",
    X_CENTER,
    Y_CENTER
  ].join(" ");
  return d;
}
const _sfc_main = {
  name: "Gauge",
  setup() {
    const { uid } = getCurrentInstance();
    return {
      uid
    };
  },
  props: {
    /**
     * Gauge value
     */
    value: {
      type: Number,
      default: 70
    },
    /**
     * Gauge min value
     */
    min: {
      type: Number,
      default: 0
    },
    /**
     * Gauge max value
     */
    max: {
      type: Number,
      default: 100
    },
    /**
     * Must be between -360 and 360
     * startAngle MUST be inferior to endAngle
     */
    startAngle: {
      type: Number,
      default: -90,
      validator: (value) => {
        if (value < -360 || value > 360) {
          console.warn('GaugeChart - props "startAngle" must be between -360 and 360');
        }
        return true;
      }
    },
    /**
     * Must be between -360 and 360
     * startAngle MUST be inferior to endAngle
     */
    endAngle: {
      type: Number,
      default: 90,
      validator: (value) => {
        if (value < -360 || value > 360) {
          console.warn('GaugeChart - props "endAngle" must be between -360 and 360');
        }
        return true;
      }
    },
    /**
     * Size of the inner radius between 0 and RADIUS
     * The closer to RADIUS, the thinner the gauge will be
     */
    innerRadius: {
      type: Number,
      default: 60,
      validator: (value) => {
        if (value < 0 || value > 100) {
          console.warn(`GaugeChart - props "innerRadius" must be between 0 and ${RADIUS}`);
        }
        return true;
      }
    },
    /**
     * Separator step, will display a separator each min + (n * separatorStep)
     * Won't display any separator if 0 or null
     */
    separatorStep: {
      type: Number,
      default: 10,
      validator: (value) => {
        if (value !== null && value < 0) {
          console.warn('GaugeChart - props "separatorStep" must be null or >= 0');
        }
        return true;
      }
    },
    /**
     * Separator Thickness, unit is in degree
     */
    separatorThickness: {
      type: Number,
      default: 4
    },
    /**
     * Gauge color. Can be :
     * - a simple color if passed as a 'string'
     * - a gradient if is an array of objects :
     * { offset: percentage where the color starts, color: color to display }
     */
    gaugeColor: {
      type: [Array, String],
      default: () => [
        { offset: 0, color: "#347AB0" },
        { offset: 100, color: "#8CDFAD" }
      ]
    },
    /**
     * Color of the base of the gauge
     */
    baseColor: {
      type: String,
      default: "#DDDDDD"
    },
    /**
     * Animation easing option
     * You can check the Tween.js doc here :
     * https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md
     *
     * There are a few existing function gourped by equation they represent:
     * Linear, Quadratic, Cubic, Quartic, Quintic, Sinusoidal, Exponential,
     * Circular, Elastic, Back and Bounce
     *
     * And then by the easing type: In, Out and InOut.
     * The syntaxe is : equation.easingType
     */
    easing: {
      type: String,
      default: "Circular.Out"
    },
    /**
     * Scale interval
     * Won't display any scall if 0 or `null`
     */
    scaleInterval: {
      type: Number,
      default: 5,
      validator: (value) => {
        if (value !== null && value < 0) {
          console.warn('GaugeChart - props "scaleInterval" must be null or >= 0');
        }
        return true;
      }
    },
    /**
     * Transition duration in ms
     */
    transitionDuration: {
      type: Number,
      default: 1500
    }
  },
  data() {
    return {
      X_CENTER,
      Y_CENTER,
      RADIUS,
      /**
       * Tweened value for the animation of the gauge
       * Starts at `min`
       * @type {Number}
       */
      tweenedValue: this.min
    };
  },
  computed: {
    /**
     * Height of the viewbox calculated by getting
     * - the lower y between the center and the start and end angle
     * - (RADIUS * 2) if one of the angle is bigger than 180Â°
     * @type {Number}
     */
    height() {
      const { endAngle, startAngle } = this;
      const { y: yStart } = polarToCartesian(RADIUS, startAngle);
      const { y: yEnd } = polarToCartesian(RADIUS, endAngle);
      return Math.abs(endAngle) <= 180 && Math.abs(startAngle) <= 180 ? Math.max(Y_CENTER, yStart, yEnd) : RADIUS * 2;
    },
    /**
     * d property of the path of the base gauge (the colored one)
     * @type {String}
     */
    basePath() {
      const { startAngle, endAngle } = this;
      return describePath(RADIUS, startAngle, endAngle);
    },
    /**
     * d property of the gauge according to the value.
     * This gauge will hide a part of the base gauge
     * @type {String}
     */
    gaugePath() {
      const { endAngle, getAngle, tweenedValue } = this;
      return describePath(RADIUS, getAngle(tweenedValue), endAngle);
    },
    /**
     * Total angle of the gauge
     * @type {Number}
     */
    totalAngle() {
      const { startAngle, endAngle } = this;
      return Math.abs(endAngle - startAngle);
    },
    /**
     * True if the gauge is a full circle
     * @type {Boolean}
     */
    isCircle() {
      return Math.abs(this.totalAngle) === 360;
    },
    /**
     * True if the gaugeColor is an array
     * Result in displaying a gradient instead of a simple color
     * @type {Boolean}
     */
    hasGradient() {
      return Array.isArray(this.gaugeColor);
    },
    /**
     * Array of the path of each separator
     */
    separatorPaths() {
      const {
        separatorStep,
        getAngle,
        min,
        max,
        separatorThickness,
        isCircle
      } = this;
      if (separatorStep > 0) {
        const paths = [];
        let i = isCircle ? min : min + separatorStep;
        for (i; i < max; i += separatorStep) {
          const angle = getAngle(i);
          const halfAngle = separatorThickness / 2;
          paths.push(describePath(RADIUS + 2, angle - halfAngle, angle + halfAngle));
        }
        return paths;
      }
      return null;
    },
    /**
     * Array of line configuration for each scale
     */
    scaleLines() {
      const {
        scaleInterval,
        isCircle,
        min,
        max,
        getAngle,
        innerRadius
      } = this;
      if (scaleInterval > 0) {
        const lines = [];
        let i = isCircle ? min + scaleInterval : min;
        for (i; i < max + scaleInterval; i += scaleInterval) {
          const angle = getAngle(i);
          const startCoordinate = polarToCartesian(innerRadius - 4, angle);
          const endCoordinate = polarToCartesian(innerRadius - 8, angle);
          lines.push({
            xS: startCoordinate.x,
            yS: startCoordinate.y,
            xE: endCoordinate.x,
            yE: endCoordinate.y
          });
        }
        return lines;
      }
      return null;
    }
  },
  watch: {
    /**
     * Watch the value and tween it to make an animation
     * If value < min, used value will be min
     * If value > max, used value will be max
     */
    value: {
      immediate: true,
      handler(next) {
        const { easing, tweenedValue, min, max, transitionDuration } = this;
        let safeValue = next;
        if (next < min) {
          safeValue = min;
        }
        if (next > max) {
          safeValue = max;
        }
        function animate() {
          if (TWEEN.update()) {
            requestAnimationFrame(animate);
          }
        }
        new TWEEN.Tween({ tweeningValue: tweenedValue }).to({ tweeningValue: safeValue }, transitionDuration).easing(_get(TWEEN.Easing, easing)).onUpdate((object) => {
          this.tweenedValue = object.tweeningValue;
        }).start();
        animate();
      }
    }
  },
  methods: {
    /**
     * Get an angle for a value
     * @param   {Number} value
     * @returns {Number} angle - in degree
     */
    getAngle(value) {
      const { min, max, startAngle, totalAngle } = this;
      const totalValue = max - min || 1;
      return value * totalAngle / totalValue + startAngle;
    }
  }
};
const _hoisted_1 = { class: "gauge" };
const _hoisted_2 = ["viewBox"];
const _hoisted_3 = ["id"];
const _hoisted_4 = /* @__PURE__ */ createElementVNode("feFlood", { "flood-color": "#c7c6c6" }, null, -1);
const _hoisted_5 = /* @__PURE__ */ createElementVNode("feComposite", {
  in2: "SourceAlpha",
  operator: "out"
}, null, -1);
const _hoisted_6 = /* @__PURE__ */ createElementVNode("feGaussianBlur", {
  stdDeviation: "2",
  result: "blur"
}, null, -1);
const _hoisted_7 = /* @__PURE__ */ createElementVNode("feComposite", {
  operator: "atop",
  in2: "SourceGraphic"
}, null, -1);
const _hoisted_8 = [
  _hoisted_4,
  _hoisted_5,
  _hoisted_6,
  _hoisted_7
];
const _hoisted_9 = ["id"];
const _hoisted_10 = ["offset", "stop-color"];
const _hoisted_11 = ["id"];
const _hoisted_12 = ["r", "cx", "cy"];
const _hoisted_13 = ["r", "cx", "cy"];
const _hoisted_14 = ["d"];
const _hoisted_15 = ["mask"];
const _hoisted_16 = ["r", "cx", "cy", "fill"];
const _hoisted_17 = ["d", "fill"];
const _hoisted_18 = ["r", "cx", "cy", "fill"];
const _hoisted_19 = ["d", "fill", "filter"];
const _hoisted_20 = ["x1", "y1", "x2", "y2", "stroke"];
const _hoisted_21 = ["height"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    $options.height ? (openBlock(), createElementBlock("svg", {
      key: 0,
      viewBox: `0 0 ${$data.RADIUS * 2} ${$options.height}`,
      height: "100%",
      width: "100%",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createElementVNode("defs", null, [
        createElementVNode("filter", {
          id: `innershadow-${$setup.uid}`
        }, _hoisted_8, 8, _hoisted_3),
        $options.hasGradient ? (openBlock(), createElementBlock("linearGradient", {
          key: 0,
          id: `gaugeGradient-${$setup.uid}`
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.gaugeColor, (color, index) => {
            return openBlock(), createElementBlock("stop", {
              key: `${color.color}-${index}`,
              offset: `${color.offset}%`,
              "stop-color": color.color
            }, null, 8, _hoisted_10);
          }), 128))
        ], 8, _hoisted_9)) : createCommentVNode("", true),
        createElementVNode("mask", {
          id: `innerCircle-${$setup.uid}`
        }, [
          createElementVNode("circle", {
            r: $data.RADIUS - 0.5,
            cx: $data.X_CENTER,
            cy: $data.Y_CENTER,
            fill: "white"
          }, null, 8, _hoisted_12),
          createElementVNode("circle", {
            r: $props.innerRadius,
            cx: $data.X_CENTER,
            cy: $data.Y_CENTER,
            fill: "black"
          }, null, 8, _hoisted_13),
          $options.separatorPaths ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($options.separatorPaths, (separator, index) => {
            return openBlock(), createElementBlock("path", {
              key: index,
              d: separator,
              fill: "black"
            }, null, 8, _hoisted_14);
          }), 128)) : createCommentVNode("", true)
        ], 8, _hoisted_11)
      ]),
      createElementVNode("g", {
        mask: `url(#innerCircle-${$setup.uid})`
      }, [
        $options.isCircle ? (openBlock(), createElementBlock("circle", {
          key: 0,
          r: $data.RADIUS,
          cx: $data.X_CENTER,
          cy: $data.Y_CENTER,
          fill: $options.hasGradient ? `url(#gaugeGradient-${$setup.uid})` : $props.gaugeColor
        }, null, 8, _hoisted_16)) : (openBlock(), createElementBlock("path", {
          key: 1,
          d: $options.basePath,
          fill: $options.hasGradient ? `url(#gaugeGradient-${$setup.uid})` : $props.gaugeColor
        }, null, 8, _hoisted_17)),
        $props.value === $props.min && $options.isCircle ? (openBlock(), createElementBlock("circle", {
          key: 2,
          r: $data.RADIUS,
          cx: $data.X_CENTER,
          cy: $data.Y_CENTER,
          fill: $props.baseColor
        }, null, 8, _hoisted_18)) : (openBlock(), createElementBlock("path", {
          key: 3,
          d: $options.gaugePath,
          fill: $props.baseColor,
          filter: `url(#innershadow-${$setup.uid})`
        }, null, 8, _hoisted_19))
      ], 8, _hoisted_15),
      $options.scaleLines ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($options.scaleLines, (line, index) => {
        return openBlock(), createElementBlock("line", {
          key: `${line.xE}-${index}`,
          x1: line.xS,
          y1: line.yS,
          x2: line.xE,
          y2: line.yE,
          "stroke-width": "1",
          stroke: $props.baseColor
        }, null, 8, _hoisted_20);
      }), 128)) : createCommentVNode("", true),
      (openBlock(), createElementBlock("foreignObject", {
        x: "0",
        y: "0",
        width: "100%",
        height: $options.height
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, _hoisted_21))
    ], 8, _hoisted_2)) : createCommentVNode("", true)
  ]);
}
const Gauge = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const VueSvgGauge = {
  install(Vue, options) {
    Vue.component("vue-svg-gauge", Gauge);
    Vue.component("VueSvgGauge", Gauge);
  }
};
let GlobalVue = null;
if (typeof window !== "undefined") {
  GlobalVue = window.Vue;
} else if (typeof global !== "undefined") {
  GlobalVue = global.Vue;
}
if (GlobalVue) {
  GlobalVue.use(VueSvgGauge);
}
export {
  Gauge as VueSvgGauge,
  VueSvgGauge as default
};
